Skill 2 教学
Hello 大家好
今天我们要讲的是如何编写一个较为复杂的skill
shootball
我们可以首先看一下左面我写好的实例：

因为我的电脑有一些卡顿，加上录屏的原因

可以分析出来我们这个skill是分为以下几个步骤的：
1.机器人运动到球一定半径范围停止
2.以球为圆心做圆周运动调整射门角度
3.当射门角度合适的时候，慢慢上前，射门
我们再来看一下

首先声明一下，这种简单的三段式一定不是获取球射门最快的方式，但是随着我们后续的分析，
我们可以发现这种方式是最稳定的。一是符合公司要写稳定demo的要求，二也可以用作大家平时训练写skill的demo范例。

这节课我们仅分析该模型在几何上的计算方式，并通过代码实现。

并且通过修改目标点的方式修改skill shootball为passball。


我们首先根据画图来分析一下我们这个模型的主要数学逻辑与状态机逻辑。


黑色的矩形代表一个场地，橙色的圆圈代表球的位置。
球门中心点的位置我们默认为我们该skill的目标点，用point target的缩写Pt来表示。

那么我们机器人的位置是随机在场上任意位置出现的，用蓝色的圆圈表示

首先，我们蓝色的圆圈也就是机器人，需要运动到距离球一定范围内

它首先要运动到Point1 点（p1来表示），为什么不直接运动到可以射门的位置呢？这是一个问题，大家可以思考一下

答案很简单，如果直接运动到可以射门的位置p2的话，那么蓝色圆圈有一定几率会撞到球，
而运动到p1这种方式，无论机器人在什么位置，都不会撞到球，这是一个最稳定靠近球的方法。

所以状态机的逻辑已经很清晰了：
1.机器人由当前位置运动到P1
2.当机器人距离P1已经很近的时候，开始绕圆弧走，直到走到P2的位置（P2为目标点Pt与球反向延长线交圆的交点）
3.当机器人距离p2已经很近的时候，可以上去准备踢球

大家可能对这个圆不太熟悉，其实这个圆就是一个很简单的安全区域，
你如果怕机器人在走圆弧的时候刮球，那么你圆的半径就可以大一点，
比如说1m（100cm），如果你想让这个skill更加的快速，便捷，迅猛，
那么你圆的半径可以小一点，比如说50cm或者更小，但是你要记得车本身也有半径呦！


1.机器人由当前位置运动到P1
2.当机器人距离P1已经很近的时候，开始绕圆弧走，直到走到P2的位置（P2为目标点Pt与球反向延长线交圆的交点）
3.当机器人距离p2已经很近的时候，可以上去准备踢球

所以这个就是我们机器人的状态机逻辑

我们现在来看如何获取各种点的位置
首先：
机器人的位置如何获取，
在player_plan函数里面传进来一个参数，叫做robot_id
这个id就是机器人的id，当前机器人的id

可以看一下我标的这两行，通过model->直接get_our_player_pos和dir，只要把robot_id传进去

如果你想知道dir传的是弧度还是角度，自己去试一下，如果我没记错的话，文档写的是错的。调试方法有两种：
1.使用刘然新版的log实时输出看一下日志
2.使用旧版的bot.txt试一下（我没试过，理论上可行）
3.将target_pos设置为你要调试的参数
比如你要调试的变量为 a
那么你可以设置target_pos(a,0)
然后看机器人的位置就可以直接在仿真器中获取a的值了
（这个是我闲着才会用的方法，建议用1）

机器人位置获取完了其实球的位置大同小异，可以看二次开发手册，在这里就不赘述了

Pt的位置其实和def里面的是一样的，只不过def里面用的是自己家的球门，取一个负号就可以用到对面的球门了。

所以现在我们看左图，蓝点，橙点，红点的坐标我们都知道了，分别是Pr（Point robot） Pb （point ball） pT（point target）

黑圆的半径我们也知道了（R 暂时= 100）

我们如何求P1和P2

根据我们上节课讲的向量的关系。
P1点可以通过Pb点向Pr点扩展R长度来实现！！！
这句话很关键，看懂了再往下看！

所以
P1 = Pb + Maths::vector2polar(R, dir)
其中dir是从ball指向Robot，也就是Pb指向Pr，也就是
Pr-Pb

所以
P1 = Pb + Maths::vector2polar(R, (Pr-Pb).angle())
角度用angle来代替
通过上面跟关键这句话来计算P1

我们再来看一下P2的计算方法

P2点可以通过Pb点向Pt与Pb的反向延长线方向扩展R长度来实现。！！！

大同小异的方法啦，反向延长线的话需要对向量的方向至反

可能你要问，为什么这两个点都要从Pb来扩展呢？
恩。。。。。。
道理很简单啊。。。。。。
因为Pb是他们俩的圆心啊。。。。。。
所以Pb到他们两个点的距离就确定了。。。。。
距离确定的话方向算一算是很简单的啦！


这个就是我们所说的简答的数学直觉和数学逻辑吧，我觉得和你学没学过微积分没什么关系，多动动脑，都很简单的。

那这样的话，我们的点的计算就非常简单了，一下子就能搞定了。

那么我们今天来到我们最难的一个部分，当确定到达P1点附近的时候，怎么走到P2点。
这个有两个问题：
1.怎么能绕着正确的方向走到P2点（一直绕着正确的方向）
2.怎么绕着弧线而不是直线走到P2（绕着黑色圆弧，而不是黄色直线示意图）

第一个问题留给你们思考，我代码里面有写
第二个问题，我们要考虑一下，我们的伺服周期
1/60秒的伺服周期，每秒执行60次skill的状态机判断，不停地生成新的targetpos，最后使得targetpos执行出来的结果是一个圆弧


这就是我们的做法


我们来看一下左边的示意图。
1表示的是我们当前的点，也就是初始点
n表示的使我们的目标点
我们如果将targetpos直接定成Pn，那么就直接走割线过去了。所以我们需要每次让机器人扩展一个小的圆弧走向Pn

我们假定P1与Pn的小于平角的夹角为 theta
我们人为设定一个小的夹角 delta theta 可以暂设为5°或者3°
我们每次根据当前点Pi扩展Pi+1，使得满足条件：Pi与Pi+1夹角为
delta theta！！！！ 这句话很关键！！！

扩展方法是，我们还是以圆心为初始点，扩展距离还是为R，但是扩展方向变了，不是原有的圆心到Pi的方向，而是圆心到Pi+1的方向，其实就是
（Pi - Pb）+- delta theta
具体是+还是-自己去研究一下
我代码里面有写


所以使用这种方法可以实现机器人绕球转调整方向。



最后我们来考虑一下扩展性的问题，作为一个skill模型，写完不能只考虑这一个问题，如果这个模型能解决很多个问题，那岂不是美滋滋？

很显然，我们这种拿球方法是任何复杂skill都需要的，稳定，效率中等。
完全可以胜任开球传球的功能，我们只需要！！！！
将Pt改为我们的队友的位置就可以啦！！！！！！
是不是很简单，思考一下！


现在教大家一下如何获取我们队友的位置
核心是利用model函数获取id
首先我们自己的id就是robot_id很简单

守门员的id就是 model->get_our_goalie()
那么还有一辆车我们的id怎么获取呢？

model->get_our_exist_id()
有一个这个函数，可以获取我们机器人的id是否存在的函数，可以通过循环扫描来实现判断我们剩下的一辆车到底是谁

在我的代码里面，
bool isPasstoReceiver = false;//true->pass false->shoot
我使用了isPasstoReceiver实现了判断是否是传给队友的标签
如果该变量为false，射门
该变量为true，传球

用这种方法，很简答就可以瞬间切换两种skill
并且根据生成不同dll改名的方法来选择不同skill


整个代码结构就是这样了额，东西比较多，尤其判断方向的部分很难自己写出来，看一下我的逻辑，然后自己实现一下？？

希望大家都可以理解skill的内容

本次视频录制真的没法说话，嗓子严重发炎，失声，导致影响视频教学的效率，再次表示歉意。如果有问题的话多多研究，多多提问！

谢谢大家！









